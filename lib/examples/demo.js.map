{"version":3,"sources":["../../src/examples/demo.js"],"names":[],"mappings":";;AACA;;;;AACA;;;;AACA;;;;;;AAEA;AACA,QAAQ,oBAAR;;AAEA;AACA;AACA;AAVA;AAWA,sBAAY,gBAAZ,CAA6B,0BAAU,MAAV,CAAiB;AAC1C,kBAAiB,qBADyB;AAE1C,oBAAiB;AAFyB,CAAjB,CAA7B;;AAKA;AACA,IAAI,SAAS,sBAAY,SAAZ,CAAsB,cAAtB,CAAb;;AAEA;AACA;AACA;AACA;AACA,IAAI,KAAK,eAAkB,MAAlB,EAA0B,IAA1B,EAAgC,UAAC,OAAD,EAAU,MAAV,EAAqB;AAC1D,eAAW,OAAX,EAAoB,GAApB,EAAyB,KAAzB;AACH,CAFQ,CAAT;AAGA,IAAI,KAAK,eAAkB,MAAlB,EAA0B,IAA1B,EAAgC,UAAC,OAAD,EAAU,MAAV,EAAqB;AAC1D,eAAW,OAAX,EAAoB,GAApB,EAAyB,KAAzB;AACH,CAFQ,CAAT;AAGA,IAAI,KAAK,eAAkB,MAAlB,EAA0B,IAA1B,EAAgC,UAAC,OAAD,EAAU,MAAV,EAAqB;AAC1D,eAAW,OAAX,EAAoB,GAApB,EAAyB,OAAzB;AACH,CAFQ,CAAT;AAGA,IAAI,KAAK,eAAkB,MAAlB,EAA0B,IAA1B,EAAgC,UAAC,OAAD,EAAU,MAAV,EAAqB;AAC1D,eAAW,OAAX,EAAoB,GAApB,EAAyB,MAAzB;AACH,CAFQ,CAAT;AAGA,IAAI,KAAK,eAAkB,MAAlB,EAA0B,IAA1B,EAAgC,UAAC,OAAD,EAAU,MAAV,EAAqB;AAC1D,eAAW,MAAX,EAAmB,GAAnB,EAAwB,UAAxB;AACH,CAFQ,CAAT;;AAIA;AACA,WAAc,GAAd,CAAkB,MAAlB,EAA0B,CAAC,EAAD,EAAK,EAAL,EAAS,EAAT,EAAa,EAAb,EAAiB,EAAjB,CAA1B,EAAgD,IAAhD,CAAqD,iBAAS;AAC1D,YAAQ,GAAR,gBAAyB,KAAzB;AACH,CAFD,EAEG,kBAAU;AACT,YAAQ,GAAR,gBAAyB,MAAzB;AACH,CAJD","file":"demo.js","sourcesContent":["/* eslint-disable no-console */\nimport opentracing from 'opentracing';\nimport lightstep from 'lightstep-tracer';\nimport TracedPromise from '../..';\n\n// Ensure the Node line numbers are accurate in stack traces\nrequire('source-map-support');\n\n// Initialize the tracing implementation, in this case LightStep is used.\n// Replace '{your_access_token}' with your LightStep access token to send the\n// tracing data to your project.\nopentracing.initGlobalTracer(lightstep.tracer({\n    access_token   : '{your_access_token}',\n    component_name : 'node/promises',\n}));\n\n// Set up an initial span to track all the subsequent work\nlet parent = opentracing.startSpan('Promises.all');\n\n// Set up the child promises that run in parallel.\n// Simply timeouts are being used here. In a real world application, these might\n// be any asynchronous operation: file i/o, database transactions, network\n// requests, etc.\nlet p1 = new TracedPromise(parent, 'p1', (resolve, reject) => {\n    setTimeout(resolve, 100, 'one');\n});\nlet p2 = new TracedPromise(parent, 'p2', (resolve, reject) => {\n    setTimeout(resolve, 200, 'two');\n});\nlet p3 = new TracedPromise(parent, 'p3', (resolve, reject) => {\n    setTimeout(resolve, 300, 'three');\n});\nlet p4 = new TracedPromise(parent, 'p4', (resolve, reject) => {\n    setTimeout(resolve, 400, 'four');\n});\nlet p5 = new TracedPromise(parent, 'p5', (resolve, reject) => {\n    setTimeout(reject, 250, 'failure!');\n});\n\n// Wait for the child promises to resolve or reject and then handle the result.\nTracedPromise.all(parent, [p1, p2, p3, p4, p5]).then(value => {\n    console.log(`Resolved: ${value}`);\n}, reason => {\n    console.log(`Rejected: ${reason}`);\n});\n"]}